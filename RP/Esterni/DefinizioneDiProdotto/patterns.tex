\section{Design Patterns}
  \subsection{Architetturali}
    \subsubsection{Architettura a microservizi}
      \begin{itemize}
       \item \textbf{Scopo:} l'architettura a microservizi è un approccio allo sviluppo di una singola applicazione come insieme di piccoli servizi, ciascuno dei quali viene eseguito da un proprio processo e comunica con un meccanismo snello, spesso una HTTP API;
       \item \textbf{Vantaggi:}
	      \begin{itemize} 
	       \item ogni microservizio è relativamente piccolo, quindi più semplice da implementare e da capire per gli sviluppatori;
	       \item ogni microservizio è indipendente dagli altri; è quindi possibile distribuire nuove versioni più frequentemente e isolare i possibili errori.
	      \end{itemize}

       \item \textbf{Svantaggi:}
	\begin{itemize}
	 \item l'architettura risulta maggiormente complessa perchè risulta essere un sistema distribuito;
	 \item la gestione di più microservizi potrebbe risultare in un carico di lavoro maggiore rispetto ad una sua versione monolitica.
	\end{itemize}
       \item \textbf{Utilizzo:}
      \end{itemize}
      
    \subsubsection{Architettura event-driven}
      \begin{itemize}
       \item \textbf{Scopo:} anche se non è un vero e proprio pattern, l'architettura event-driven è un particolare tipo di architettura asincrona per sistemi distribuiti basata sugli eventi.
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item per definizione, questo tipo di architettura è particolarmente adatto ad ambienti di tipo asincrono basati sugli eventi, come ad esempio l'interazione con degli utenti in tempo reale.
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item i sistemi che utilizzano tale architettura sono spesso distribuiti: ciò comporta un maggiore livello di complessità.
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}
     
     \subsubsection{Client-side discovery}
      \begin{itemize}
       \item \textbf{Scopo:} all'interno di un'architettura a microservizi, i singoli microservizi si trovano spesso in posizioni non fissate in quanto decise dinamicamente. Un metodo per la loro localizzazione consiste nel pattern Client-side discovery, che consiste nella richiesta della posizione di uno specifico microservizio da parte del client ad un registro, che conosce le posizioni di tutte le istanze dei microservizi. 
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item permette di allocare dinamicamente diverse istanze di diversi servizi.
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item crea dipendenze tra il registro e il client.
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}

    
   \subsubsection{Data Access Object}
      \begin{itemize}
       \item \textbf{Scopo:} il pattern Data Access Object (DAO) consiste nell'utilizzo di un oggetto che fornisce un'interfaccia astratta per la gestione di un database, o più in generale per la gestione della persistenza.
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item separazione tra logica di business e dati;
	   \item modifiche sul dati non comportano modifiche sul client cche utilizza DAO.
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item un'interfaccia di questo tipo potrebbe nascondere i costi di accesso ad un database;
	   \item potrebbe essere necessarie molte più operazioni rispetto all'esecuzione diretta di una query su un database.
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}
	
    \subsubsection{Dependency Injection}
     \begin{itemize}
       \item \textbf{Scopo:} consiste nella separazione del comportamento di una componente dalla risoluzione delle sue dipendenze.
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item la separazione del comportamento dalle dipendenze rende una componente molto più flessibile;
	   \item rende le singole componenti maggiormente indipendenti permettendo una più facile progettazione dei test di unità.
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item eventuali errori legati alla risoluzione delle dipendenze o alla loro implementazione vengono rilevati solamente a runtime;
	   \item rende più difficile il tracciamento del codice in quanto ne separa la costruzione dal comportamento.
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}
  
  \subsection{Strutturali}
  
    \subsubsection{Facade}
      \begin{itemize}
       \item \textbf{Scopo:}  indica un oggetto che permette, attraverso un'interfaccia più semplice, l'accesso a sottosistemi che espongono interfacce complesse e molto diverse tra loro, nonché a blocchi di codice complessi. 
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item permette di nascondere la complessità di un'operazione: rispetto alla chiamata diretta di un sottoinsieme di classi è possibile chiamare solamente la classe definita come facade semplificando l'operazione;
	   \item permette di diminuire le dipendenze tra sottosistemi;
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item i sottosistemi risultano essere collegati al facade: modifiche alla struttura dei sottosistemi comportano una serie di modifiche al facade stesso;
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}
	
    \subsubsection{Adapter}
      \begin{itemize}
       \item \textbf{Scopo:} questo pattern permette la comunicazione tra due interfacce completamente differenti tramite l'utilizzo di un Adapter.
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item permette la conversione di una classe esistente in un'altra completamente differente senza modificarne il codice;
	   \item maggiore flessibilità nella progettazione.
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item aumenta la dimensione del codice;
	   \item a volte per interconnettere due interfacce sono necessari più Adapter.
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}
	
  \subsection{Creazionali}
  
    \subsubsection{Singleton}
      \begin{itemize}
       \item \textbf{Scopo:} questo pattern ha lo scopo di garantire che di una determinata classe venga creata una e una sola istanza, e di fornire un punto di accesso globale ad essa.
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item questo pattern risulta molto utile ogni qual volta è necessaria una sola istanza di una classe.
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item la classe Singleton risulta essere globale, e di conseguenza rende più difficile la definizione di test di unità;
	   \item aumenta il livello di accoppiamento del codice.
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}
	
  \subsection{Comportamentali}
  
    \subsubsection{Observer}
      \begin{itemize}
       \item \textbf{Scopo:} questo pattern permette la definizione di una o più classi Observer le quali "osservano" una classe Soggetto e ne gestiscono gli eventi.
	\item \textbf{Vantaggi:}
	  \begin{itemize}
	   \item permette la gestione di eventi tramite l'invio di dati ad altre classi in modo efficiente;
	   \item la definizione di classi Observer non causa modifiche alla classe Soggetto. 
	  \end{itemize}
	\item \textbf{Svantaggi:}
	  \begin{itemize}
	   \item una cattiva implementazione comporta un aumento della complessità del codice;
	   \item l'interfaccia Observer deve essere implementata, e ciò comporta ereditarietà.
	  \end{itemize}
	\item \textbf{Utilizzo:}
	\end{itemize}