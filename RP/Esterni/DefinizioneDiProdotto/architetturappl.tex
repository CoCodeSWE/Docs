\section{Architettura dell'applicazione}
L'architettura scelta è quella a microservizi.\\
\subsection{Microservizi}
Di seguito verranno esposti e spiegati i funzionamenti di ogni microservizio da implementare.
\subsubsection{Virtual Assistant}
\paragraph{Descrizione}
Il microservizio Virtual Assistant fornisce le funzionalità di un assistente virtuale. Fa affidamento ad api.ai, e si occupa di inoltrare le richieste ricevute a tale infrastruttura. Avvalendosi di un database, permette di utilizzare diversi agenti durante la stessa interazione, consentendo quindi di definire diverse "applicazioni". Per ogni applicazione, si dovrà definire un agente.\\ Le richieste fatte all'unico endpoint di questo microservizio richiedono infatti di comunicare anche il nome dell'applicazione a cui è legata la richiesta. Questo permette di separare in diversi agenti di api.ai dialoghi legati a diverse funzionalità, consentendo lo sviluppo di diverse funzionalità da parte di sviluppatori diversi, e l'integrazione di eventuali funzionalità già esistenti senza dover modificare direttamente gli agenti di api.ai. \\
Per avere un completo controllo sul flusso della conversazione, si dovrà fare utilizzo di un database contenente gli agenti utilizzabili, in maniera tale che gli agenti utilizzabili siano solo quelli definiti e registrati.\\
Il microservizio si occupa anche di notificare, tramite l'utilizzo di AWS SNS, dell'avvenuta interazione da parte dell'utente, permettendo così il salvataggio delle conversazioni in un database di supporto, il quale potrebbe essere utilizzato magari per fini di apprendimento macchina.\\
Di seguito vengono esposti i vari passaggi:
\begin{itemize}
	\item arriva una richiesta;
	\item interrogo il database, contenente gli agenti, utilizzando il nome dell'applicazione;
	\item dall'interrogazione precedente ottengo il token dell'agente relativo all'applicazione;
	\item invio ad api.ai il token e il testo della richiesta;
	\item api.ai fornisce la risposta, la quale viene "filtrata" da\\ \file{Back-end::VirtualAssistant::ApiAiVAAdapter::query(str: VAQuery): VAResponse}, ottenendo così un formato adatto a \file{Back-end::VirtualAssistant::VAResponse};
	\item pubblico, tramite il servizio Amazon SNS, la risposta filtrata che verrà quindi inviata al Client.
\end{itemize}
\paragraph{Endpoints}

Ora verranno definiti gli Endpoints utilizzati per i passaggi di risorse con il microservizio Virtual Assistant.\\
Per ogni risorsa sono stati specificati i formati per lo scambio dei dati in JSON: 
\begin{itemize}
\item \textbf{Request:} rappresenta l’oggetto JSON che dovrà essere passato alla risorsa REST;
\item \textbf{Response:} rappresenta l’oggetto JSON che fornirà in risposta la risorsa REST.
\end{itemize}
Gli Endpoints sono: 
\begin{itemize}
\item \textbf{/query}\\
\begin{itemize}
\item \textbf{Method:} POST;
\item \textbf{Descrizione:} invia al microservizio il testo utilizzato per l'esecuzione di un'interrogazione;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	"VAQuery" : ["array di JSON contenente i dati necessari per l'interrogazione"]
}
\end{lstlisting}
\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	"VAResponse" : ["array di JSON contenente dati associati alla risposta di Virtual Assistant"]
}
\end{lstlisting}
\end{itemize}
\end{itemize}


\subsubsection{Notifications}
\paragraph{Descrizione}
Il microservizio Notifications si occupa di mandare messaggi di notifica nei canali adeguati per notificare gli interessati dell'arrivo di un'ospite in azienda. Fornisce le API per richiedere la lista dei possibili destinatari, e per mandare il messaggio di notifica in un determinato canale. La lista dei canali viene restituita come un'array di stringhe, ognuna delle quali rappresenta un canale.\\
Il microservizio si occupa di interrogare le diverse liste fornite dalla piattaforma di messaggistica scelta e di combinarle in un'unica lista. Nel nostro caso, la piattaforma di messaggistica è Slack e le diverse liste fornite riguardano utente, canali e gruppi privati. Quando si vuole mandare un messaggio, il campo \file{Back-end::Notifications::NotificationMessageEvent::send\_to} indica chi è il destinatario di tale messaggio.\\ \file{Back-end::Notifications::NotificationMessageEvent::msg} invece contiene il messaggio vero e proprio, nel formato definito dalla piattaforma di messaggistica su cui si appoggia il microservizio. Il formato utilizzato da Slack è consultabile qui \url{https://api.slack.com/docs/message-buttons}.
\paragraph{Endpoints}

Ora verranno definiti gli Endpoints utilizzati per i passaggi di risorse con il microservizio Notifications. \\
Per ogni risorsa sono stati specificati i formati per lo scambio dei dati in JSON: 
\begin{itemize}
\item \textbf{Request:} rappresenta l’oggetto JSON che dovrà essere passato alla risorsa REST;
\item \textbf{Response:} rappresenta l’oggetto JSON che fornirà in risposta la risorsa REST.
\end{itemize}
Gli Endpoints sono: 
\begin{itemize}

\item \textbf{/}\\
\begin{itemize}
\item \textbf{Method:} GET;
\item \textbf{Descrizione:} restituisce la lista dei possibili destinatari;
\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	receiver_array : ["array di stringhe dei possibili destinatari"]
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} POST;
\item \textbf{Descrizione:} invia la notifica ad una determinata persona;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	rule : ["array di JSON contente i dati associati alla direttiva da inviare"]
	sender : ["stringa contenente il mittente della notifica "]
	receiver : ["stringa contenente il destinatario della notifica "]
	msg : ["stringa contenente il messaggio da inviare"]
}
\end{lstlisting}
\end{itemize}
\end{itemize}

\subsubsection{Users}
\paragraph{Descrizione}
Il microservizio Users si occupa della gestione degli amministratori del nostro sistema. Esso fornisce delle API REST per modificare i dati relativi agli amministratori del nostro sistema presenti in un database. Viene integrato col servizio di Speech Recognition dall'API Gateway, per fornire la possibilità di effettuare il login, tramite impronta vocale, nel sistema.
\paragraph{Endpoints}

Ora verranno definiti gli Endpoints utilizzati per i passaggi di risorse con il microservizio Users. \\
Per ogni risorsa sono stati specificati i formati per lo scambio dei dati in JSON: 
\begin{itemize}
\item \textbf{Request:} rappresenta l’oggetto JSON che dovrà essere passato alla risorsa REST;
\item \textbf{Response:} rappresenta l’oggetto JSON che fornirà in risposta la risorsa REST.
\end{itemize}

Gli Endpoints sono:
 
\begin{itemize}
\item \textbf{/auth/users}\\
\begin{itemize}
\item \textbf{Method:} GET;
\item \textbf{Descrizione:} restituisce la lista degli Users;  
\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} POST;
\item \textbf{Descrizione:} vengono inviati i dati necessari alla registrazione; 
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	user_array : ["array di stringhe degli utenti esistenti"]
}
\end{lstlisting}
\end{itemize}

\item \textbf{/auth/users/:username}\\

\begin{itemize}
\item \textbf{Method:} PUT;
\item \textbf{Descrizione:} vengono modificati i dati dell'utente tramite sovrascrittura; 
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	user : ["array di JSON contenente i nuovi dati da inserire"]	
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} DELETE;
\item \textbf{Descrizione:} viene eliminato un utente; 
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	username : ["stringa contenente l'username dell'utente da eliminare"]
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} GET;
\item \textbf{Descrizione:} vengono ricevuti i dati relativi ad un utente; 
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	username : ["stringa contenente l'username dell'utente desiderato"]
}
\end{lstlisting}

\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	user : ["array di JSON contenente l'utente desiderato"]
}
\end{lstlisting}
\end{itemize}

\end{itemize}

\subsubsection{Rules}
\paragraph{Descrizione}
Il microservizio Rules si occupa della gestione delle direttive del sistema. Una direttiva è un'istruzione che viene data da un amministratore al sistema, la quale permette di modificare il comportamento del sistema stesso al verificarsi di certe condizioni. Tali condizioni possono essere legate alla persona che interagisce col sistema, la sua azienda di provenienza, oppure alla persona desiderata che viene richiesta.\\
Il sistema fornisce una serie di funzioni per modificare il suo comportamento, le quali indicano il modo in cui esso debba essere cambiato. \\
Una direttiva è costituita da:
\begin{itemize}
	\item una lista di target, che indica gli obbiettivi ai quali deve essere applicata la direttiva;
	\item un'istanza di funzione, che indica quale delle funzioni disponibili deve essere applicata e, nel caso in cui tale funzione abbia dei parametri modificabili, con quali valori di quest'ultimi deve essere chiamata;
	\item un nome, il quale permette agli amministratori di identificare le diverse direttive;
	\item un id, il quale identifica univocamente la funzione all'interno del sistema; 
	\item una flag di abilitazione, che permette di abilitare e disabilitare l'applicazione della direttiva da parte del sistema.
\end{itemize}
  
\paragraph{Endpoints}

Ora verranno definiti gli Endpoints utilizzati per i passaggi di risorse con il microservizio Rules.\\ 
Per ogni risorsa sono stati specificati i formati per lo scambio dei dati in JSON: 
\begin{itemize}
\item \textbf{Request:} rappresenta l’oggetto JSON che dovrà essere passato alla risorsa REST;
\item \textbf{Response:} rappresenta l’oggetto JSON che fornirà in risposta la risorsa REST.
\end{itemize}
Gli Endpoints sono: 

\begin{itemize}

\item \textbf{/impostazioni}\\

\begin{itemize}
\item \textbf{Method:} GET;
\item \textbf{Descrizione:} viene ricevuta la lista delle direttive;
\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	rule_array : ["array di stringhe contenente la lista delle direttive"]
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} POST;
\item \textbf{Descrizione:} viene creata una nuova direttiva
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	rule : ["array di JSON contenente i dati associati alla direttiva da creare"]
}
\end{lstlisting}
\end{itemize}

\item \textbf{/impostazioni/:id}\\

\begin{itemize}
\item \textbf{Method:} PUT; 
\item \textbf{Descrizione:} viene modificata una direttiva tramite sovrascrittura;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	rule : ["array di JSON contenente i nuovi dati associati alla direttiva da modificare"]
}
\end{lstlisting} 

\end{itemize}

\begin{itemize}
\item \textbf{Method:} GET;
\item \textbf{Descrizione:} vengono richiesti dati relativi ad una specifica direttiva;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	id_rule : ["stringa contenente l'id della direttiva desiderata"]
}
\end{lstlisting}
\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	rule : ["array di JSON contenente i dati associati alla direttiva desiderata"]
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} DELETE;
\item \textbf{Descrizione:} viene eliminata una direttiva;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	id_rule : ["stringa contenente l'id della direttiva da eliminare"]
}
\end{lstlisting}
\end{itemize}


\item \textbf{/impostazioni/functions/}\\

\begin{itemize}
\item \textbf{Method:} GET; 
\item \textbf{Descrizione:} viene richiesta la lista dei tipi di funzioni presenti nel sistema; 
\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	function_array : ["array di stringhe contenente la lista dei tipi di funzioni presenti nel sistema"]
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} POST;
\item \textbf{Descrizione:} viene creato un nuovo tipo di funzione;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	function : ["array di JSON contenente il tipo di funzione da creare"]
}
\end{lstlisting}  
\end{itemize}



\item \textbf{/impostazioni/functions/:type}\\

\begin{itemize}
\item \textbf{Method:} GET;
\item \textbf{Descrizione:} viene richiesta la descrizione di una funzione;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	id_function : ["stringa contenente l'id della funzione richiesta"]
}
\end{lstlisting}
\item \textbf{Response:} la risposta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	description_function : ["stringa contenente la descrizione della funzione richiesta"]
}
\end{lstlisting}
\end{itemize}

\begin{itemize}
\item \textbf{Method:} PUT;
\item \textbf{Descrizione:} viene modificata una funzione tramite sovrascrittura;
\item \textbf{Request:} la richiesta deve contenere i seguenti campi:
\begin{lstlisting}[language=json,firstnumber=1]
{
	function : ["array di JSON contenente i nuovi dati associati alla funzione da modificare"]
}
\end{lstlisting}

\end{itemize}

\end{itemize}

\end{document}


